# code for mobile sale data analysis


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import re

# Load the dataset
data = pd.read_csv(r'C:\Users\Ankit Sharma\OneDrive\Desktop\Chakr innovation\Assignment - Junior Data Analyst.csv')


# Display the first few rows and basic information about the dataset
print(data.head())


# Convert 'reviews' to numeric (remove commas and convert to int)
data['reviews'] = data['reviews'].str.replace(',', '').str.extract('(\d+)').astype(float)


#Univariate Analysis - Price column
data['price'].describe()#to get an idea about the distribution of rating to set the bins

count, bin_edges = np.histogram(data['price'].dropna(), bins=np.arange(0,data['price'].max(), 5000))
plt.figure(figsize=(20, 6))
plt.hist(data['price'].dropna(), bins=np.arange(0, data['price'].max(), 5000), 
         edgecolor='black', color='red')
plt.title('Price Distribution')
plt.xlabel('Price')
plt.ylabel('Frequency')

# Annotate the frequency count on the bars-price


# Annotate the frequency count on the bars
for i in range(len(bin_edges) - 1):
    plt.text((bin_edges[i] + bin_edges[i + 1]) / 2, count[i] , str(count[i]), ha='center', va='bottom')

plt.xticks(bin_edges, rotation=45)

plt.show()

#Univariate Analysis - rating

data['rating'].describe()#to get an idea about the distribution of rating to set the bins

count, bin_edges = np.histogram(data['rating'].dropna(), bins=np.arange(2.5,data['rating'].max(), 0.1))
plt.figure(figsize=(12, 6))
plt.hist(data['rating'].dropna(), bins=np.arange(2.5, data['rating'].max(), 0.1), edgecolor='black', color='red')
plt.title('Rating Distribution')
plt.xlabel('Rating')
plt.ylabel('Frequency')

# Annotate the frequency count on the bars-rating
for i in range(len(bin_edges) - 1):
    plt.text((bin_edges[i] + bin_edges[i + 1]) / 2, count[i], str(count[i]), ha='center', va='bottom')

plt.xticks(bin_edges, rotation=45)
plt.tight_layout()
plt.show()


#Univariate Analysis - reviews
data['reviews'].describe()#to get an idea about the distribution of rating to set the bins

count, bin_edges = np.histogram(data['reviews'].dropna(), bins=np.arange(0,data['reviews'].max(), 5000))
plt.figure(figsize=(15, 6))
plt.hist(data['reviews'].dropna(), bins=np.arange(0, data['reviews'].max(), 5000), edgecolor='black', color='red')
plt.title('reviews Distribution')
plt.xlabel('reviews')
plt.ylabel('Frequency')

# Annotate the frequency count on the bars-rating
for i in range(len(bin_edges) - 1):
    plt.text((bin_edges[i] + bin_edges[i + 1]) / 2, count[i], str(count[i]), ha='center', va='bottom')

plt.xticks(bin_edges, rotation=45)
plt.tight_layout()
plt.show()

data[['price', 'reviews', 'rating']].describe().round(2)

#categorical_column = ['battery','camera','display','memory','name','processor','warranty']
pd.set_option('display.max_rows',None)
pd.set_option('display.max_columns',None)
data[['battery','camera','display','memory','name','processor','warranty']].describe()
def plot_univariate(column_name, xlabel):
    data_column = data[column_name]
    # Count frequencies
    freq = data_column.value_counts()

    # Get top 10 and bottom 10 (if there are fewer than 10 unique values, it will show all)
    top_10 = freq.head(10)
    bottom_10 = freq.tail(10)

    # Combine them
    combined = pd.concat([top_10, bottom_10])

    # Plot
    plt.figure(figsize=(12, 6))
    ax = sns.barplot(y=combined.index, x=combined.values, palette='viridis', orient='h')

    # Add frequency and percentage labels
    total = combined.sum()
    
    # Find maximum x value to adjust the annotation placement
    max_value = max(combined.values)
    plt.xlim(0, max_value * 1.1)  # Extend x-axis a bit to the right for annotations

    for i in range(len(combined)):
        value = combined.values[i]
        percentage = (value / total) * 100
        # Frequency and percentage label on the right of the bar
        ax.text(value + max_value * 0.02, i, f'{value} ({percentage:.1f}%)', ha='left', va='center', fontsize=10, color='black')

    plt.xlabel('Frequency')
    plt.ylabel(xlabel)
    plt.title(f'Top 10 and Bottom 10 {xlabel} with Frequencies and Percentages')
    plt.show()

# Plot for each column
plot_univariate('battery', 'Battery Type')
plot_univariate('camera', 'Camera Type')
plot_univariate('display', 'Display Type')
plot_univariate('memory', 'Memory')
plot_univariate('name', 'Mobile Name')
plot_univariate('processor', 'Processor Type')
plot_univariate('warranty', 'Warranty')



#bivariate analysis

def extract_numeric(text):
    # Extract numeric values from text using regular expressions
    num = re.findall(r'[\d.]+', str(text))
    return float(num[0]) if num else np.nan

# Extract numeric values for analysis

# Extracting numeric values from 'battery' column (e.g., '5000 mAh Battery' -> 5000)
data['battery_mAh'] = data['battery'].apply(lambda x: extract_numeric(x))

# Extracting primary camera resolution from the 'camera' column (e.g., '12MP + 2MP' -> 12)
data['primary_camera_MP'] = data['camera'].apply(lambda x: extract_numeric(x))
# Extracting primary camera resolution from the 'camera' column (e.g., '12MP + 2MP' -> 12)
data['front_camera_MP'] = data['camera'].apply(lambda x: extract_numeric(x.split('| ')[-1]))

# Extracting screen size from the 'display' column (e.g., '15.8 cm (6.22 inch) HD+ Display' -> 6.22)
data['display_inches'] = data['display'].apply(lambda x: extract_numeric(x.split('inch')[0]))

# Extracting RAM size from the 'memory' column (e.g., '4 GB RAM | 64 GB ROM' -> 4)
data['RAM_GB'] = data['memory'].apply(lambda x: extract_numeric(x.split('RAM')[0]))

# Extracting ROM size from the 'memory' column (e.g., '4 GB RAM | 64 GB ROM' -> 64)
data['ROM_GB'] = data['memory'].apply(lambda x: extract_numeric(x.split('RAM | ')[-1]))

# Clean up 'reviews' column by removing commas and converting to numeric (e.g., '55,078 Reviews' -> 55078)
data['reviews_cleaned'] = data['reviews'].str.replace(',', '').str.extract('(\d+)').astype(float)

# Select columns for correlation analysis
correlation_columns = ['price', 'rating', 'battery_mAh', 'primary_camera_MP','front_camera_MP', 'display_inches', 'RAM_GB', 'ROM_GB', 'reviews_cleaned']

# Compute the correlation matrix
correlation_matrix = data[correlation_columns].corr()

# Plot the correlation matrix using a heatmap
plt.figure(figsize=(20, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Matrix for Price and Rating Analysis')
plt.show()



